// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/bhbosman/gocommon/services/ISendMessage (interfaces: ISendMessage,IMultiSendMessage)

// Package ISendMessage is a generated GoMock package.
package ISendMessage

import (
	"context"
	fmt "fmt"

	errors "github.com/bhbosman/gocommon/errors"
)

// Interface A Comment
// Interface github.com/bhbosman/gocommon/services/ISendMessage
// Interface ISendMessage
// Interface ISendMessage, Method: Send
type ISendMessageSendIn struct {
	arg0 interface{}
}

type ISendMessageSendOut struct {
	Args0 error
}
type ISendMessageSendError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *ISendMessageSendError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type ISendMessageSend struct {
	inData         ISendMessageSendIn
	outDataChannel chan ISendMessageSendOut
}

func NewISendMessageSend(waitToComplete bool, arg0 interface{}) *ISendMessageSend {
	var outDataChannel chan ISendMessageSendOut
	if waitToComplete {
		outDataChannel = make(chan ISendMessageSendOut)
	} else {
		outDataChannel = nil
	}
	return &ISendMessageSend{
		inData: ISendMessageSendIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *ISendMessageSend) Wait(onError func(interfaceName string, methodName string, err error) error) (ISendMessageSendOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &ISendMessageSendError{
			InterfaceName: "ISendMessage",
			MethodName:    "Send",
			Reason:        "Channel for ISendMessage::Send returned false",
		}
		if onError != nil {
			err := onError("ISendMessage", "Send", generatedError)
			return ISendMessageSendOut{}, err
		} else {
			return ISendMessageSendOut{}, generatedError
		}
	}
	return data, nil
}

func (self *ISendMessageSend) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallISendMessageSend(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 interface{}) (ISendMessageSendOut, error) {
	if context != nil && context.Err() != nil {
		return ISendMessageSendOut{}, context.Err()
	}
	data := NewISendMessageSend(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *ISendMessageSend) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return ISendMessageSendOut{}, context.Err()
	}
	channel <- data
	var err error
	var v ISendMessageSendOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return ISendMessageSendOut{}, err
	}
	return v, nil
}

func ChannelEventsForISendMessage(next ISendMessage, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *ISendMessageSend:
		data := ISendMessageSendOut{}
		data.Args0 = next.Send(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}

// Interface A Comment
// Interface github.com/bhbosman/gocommon/services/ISendMessage
// Interface IMultiSendMessage
// Interface IMultiSendMessage, Method: MultiSend
type IMultiSendMessageMultiSendIn struct {
	arg0 []interface{}
}

type IMultiSendMessageMultiSendOut struct {
}
type IMultiSendMessageMultiSendError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IMultiSendMessageMultiSendError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IMultiSendMessageMultiSend struct {
	inData         IMultiSendMessageMultiSendIn
	outDataChannel chan IMultiSendMessageMultiSendOut
}

func NewIMultiSendMessageMultiSend(waitToComplete bool, arg0 ...interface{}) *IMultiSendMessageMultiSend {
	var outDataChannel chan IMultiSendMessageMultiSendOut
	if waitToComplete {
		outDataChannel = make(chan IMultiSendMessageMultiSendOut)
	} else {
		outDataChannel = nil
	}
	return &IMultiSendMessageMultiSend{
		inData: IMultiSendMessageMultiSendIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IMultiSendMessageMultiSend) Wait(onError func(interfaceName string, methodName string, err error) error) (IMultiSendMessageMultiSendOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IMultiSendMessageMultiSendError{
			InterfaceName: "IMultiSendMessage",
			MethodName:    "MultiSend",
			Reason:        "Channel for IMultiSendMessage::MultiSend returned false",
		}
		if onError != nil {
			err := onError("IMultiSendMessage", "MultiSend", generatedError)
			return IMultiSendMessageMultiSendOut{}, err
		} else {
			return IMultiSendMessageMultiSendOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IMultiSendMessageMultiSend) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIMultiSendMessageMultiSend(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 ...interface{}) (IMultiSendMessageMultiSendOut, error) {
	if context != nil && context.Err() != nil {
		return IMultiSendMessageMultiSendOut{}, context.Err()
	}
	data := NewIMultiSendMessageMultiSend(waitToComplete, arg0...)
	if waitToComplete {
		defer func(data *IMultiSendMessageMultiSend) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IMultiSendMessageMultiSendOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IMultiSendMessageMultiSendOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IMultiSendMessageMultiSendOut{}, err
	}
	return v, nil
}

func ChannelEventsForIMultiSendMessage(next IMultiSendMessage, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *IMultiSendMessageMultiSend:
		data := IMultiSendMessageMultiSendOut{}
		next.MultiSend(v.inData.arg0...)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}
