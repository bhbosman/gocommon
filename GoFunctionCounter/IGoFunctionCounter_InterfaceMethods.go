// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/bhbosman/gocommon/GoFunctionCounter (interfaces: IGoFunctionCounter)

// Package GoFunctionCounter is a generated GoMock package.
package GoFunctionCounter

import (
	fmt "fmt"

	errors "github.com/bhbosman/gocommon/errors"
	"golang.org/x/net/context"
)

// Interface A Comment
// Interface github.com/bhbosman/gocommon/GoFunctionCounter
// Interface IGoFunctionCounter
// Interface IGoFunctionCounter, Method: Add
type IGoFunctionCounterAddIn struct {
	arg0 string
}

type IGoFunctionCounterAddOut struct {
	Args0 error
}
type IGoFunctionCounterAddError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IGoFunctionCounterAddError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IGoFunctionCounterAdd struct {
	inData         IGoFunctionCounterAddIn
	outDataChannel chan IGoFunctionCounterAddOut
}

func NewIGoFunctionCounterAdd(waitToComplete bool, arg0 string) *IGoFunctionCounterAdd {
	var outDataChannel chan IGoFunctionCounterAddOut
	if waitToComplete {
		outDataChannel = make(chan IGoFunctionCounterAddOut)
	} else {
		outDataChannel = nil
	}
	return &IGoFunctionCounterAdd{
		inData: IGoFunctionCounterAddIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IGoFunctionCounterAdd) Wait(onError func(interfaceName string, methodName string, err error) error) (IGoFunctionCounterAddOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IGoFunctionCounterAddError{
			InterfaceName: "IGoFunctionCounter",
			MethodName:    "Add",
			Reason:        "Channel for IGoFunctionCounter::Add returned false",
		}
		if onError != nil {
			err := onError("IGoFunctionCounter", "Add", generatedError)
			return IGoFunctionCounterAddOut{}, err
		} else {
			return IGoFunctionCounterAddOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IGoFunctionCounterAdd) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIGoFunctionCounterAdd(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IGoFunctionCounterAddOut, error) {
	if context != nil && context.Err() != nil {
		return IGoFunctionCounterAddOut{}, context.Err()
	}
	data := NewIGoFunctionCounterAdd(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IGoFunctionCounterAdd) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IGoFunctionCounterAddOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IGoFunctionCounterAddOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IGoFunctionCounterAddOut{}, err
	}
	return v, nil
}

// Interface IGoFunctionCounter, Method: Remove
type IGoFunctionCounterRemoveIn struct {
	arg0 string
}

type IGoFunctionCounterRemoveOut struct {
	Args0 error
}
type IGoFunctionCounterRemoveError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IGoFunctionCounterRemoveError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IGoFunctionCounterRemove struct {
	inData         IGoFunctionCounterRemoveIn
	outDataChannel chan IGoFunctionCounterRemoveOut
}

func NewIGoFunctionCounterRemove(waitToComplete bool, arg0 string) *IGoFunctionCounterRemove {
	var outDataChannel chan IGoFunctionCounterRemoveOut
	if waitToComplete {
		outDataChannel = make(chan IGoFunctionCounterRemoveOut)
	} else {
		outDataChannel = nil
	}
	return &IGoFunctionCounterRemove{
		inData: IGoFunctionCounterRemoveIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IGoFunctionCounterRemove) Wait(onError func(interfaceName string, methodName string, err error) error) (IGoFunctionCounterRemoveOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IGoFunctionCounterRemoveError{
			InterfaceName: "IGoFunctionCounter",
			MethodName:    "Remove",
			Reason:        "Channel for IGoFunctionCounter::Remove returned false",
		}
		if onError != nil {
			err := onError("IGoFunctionCounter", "Remove", generatedError)
			return IGoFunctionCounterRemoveOut{}, err
		} else {
			return IGoFunctionCounterRemoveOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IGoFunctionCounterRemove) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIGoFunctionCounterRemove(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IGoFunctionCounterRemoveOut, error) {
	if context != nil && context.Err() != nil {
		return IGoFunctionCounterRemoveOut{}, context.Err()
	}
	data := NewIGoFunctionCounterRemove(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IGoFunctionCounterRemove) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IGoFunctionCounterRemoveOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IGoFunctionCounterRemoveOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IGoFunctionCounterRemoveOut{}, err
	}
	return v, nil
}

func ChannelEventsForIGoFunctionCounter(next IGoFunctionCounter, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *IGoFunctionCounterAdd:
		data := IGoFunctionCounterAddOut{}
		data.Args0 = next.Add(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IGoFunctionCounterRemove:
		data := IGoFunctionCounterRemoveOut{}
		data.Args0 = next.Remove(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}
